tks = 177560
tkb = 177562
tps = 177564
tpb = 177566
lcs = 177546

.= torg + 60
.word cmdInput, 200

.= torg + 2000
main: mov #main, sp

      mov #cmdPrmt, -(sp)         ; cmdPrmt="$ "
      mov #mainPrmt, -(sp)        ; mainPrmt="Welcome!"
      mov #2, -(sp)               ; num of strings to print
      jsr pc, printText
      cmp (sp)+, (sp)+
      tst (sp)+

      mov #TEMPCMD, CMDIT         ; init TEMPCMD dynamic end address
      bis #1, tps
      mov #101, tks               ; turning on keyboard interupt

loop: wait                        ; waiting for keyboard interupt
      bit #1, tks                 ; if tks is down than end the program ("quit" command)
      bne loop

      jmp finish

cmdInput: ; using CMDIT for chars iterator on TEMPCMD
; this is the main program which gets chars and stores them in TEMPCMD
; after analizing the command, the relevant subrutine is called

      cmpb Ctrl, #0       ; check if current state is "commands input"
      beq pass2
      jmp imgInput
pass2:
      mov r1, -(sp)
      mov r2, -(sp)

      clr r1
      movb tkb, r1            ; gets the given char and stores it in r1

              cmp r1, #'\b
              bne cmdInpEnter
              cmp CMDIT, #TEMPCMD      ; CMDIT=dymanic cmd's addres
              beq cmdInpFinish
              dec CMDIT
              movb #0, @CMDIT       ; CMDIT=dymanic cmd's Address
              br cmdInpPrint

cmdInpEnter:  cmp r1, #'\r        ; is Enter?
              bne cmdInpUpdate
cmdPrtLF:     bit #200, tps         ; prints new line if an Enter was given
              beq cmdPrtLF
              mov #'\n, tpb
cmdPrtCR:     bit #200, tps
              beq cmdPrtCR
              mov #'\r, tpb
              movb #'&, @CMDIT     ; set "&" at the end of the given command
              inc CMDIT
              jsr pc, parseCmd      ; transfer all data from TEMPCMD to CMDLINE without spaces in format: "encode&4&10&@"
              jmp FUNCS             ; all functions are treated at FUNCS label

cmdInpUpdate: movb r1, @CMDIT     ; CMDIT=dynamic cmd's address
              inc CMDIT
              br cmdInpPrint

cmdIpBS1:     mov #40, r1         ; if Backspace was given, than prints prints \b than " " than \b again
              bit #200, tps
              beq cmdIpBS1
              mov r1, tpb
cmdIpBS2:     mov #'\b, r1
              bit #200, tps
              beq cmdIpBS2
              mov r1, tpb
              br cmdInpFinish
cmdInpPrint:  bit #200, tps
              beq cmdInpPrint
              mov r1, tpb
              cmp r1, #'\b
              bne cmdInpFinish
              br cmdIpBS1

clrFinishCmd: mov #TEMPCMD, CMDIT        ; init TEMPCMD pointer to the beggining after command has been proccessed
finLoop1:     bit #200, tps              ; for getting the next command
              beq finLoop1
              mov #'$, tpb
finLoop2:     bit #200, tps               ; prints "$ " in the begging of the line before letting the user call another command
              beq finLoop2
              mov #40, tpb
cmdInpFinish: mov #101, tks
              cmpb Ctrl, #-1              ; if Ctrl is -1 than do "rti" without restoring r1, r2 because is was restored once before
              bne cmdIpEnd                ; Ctrl=-1 when a sub complex command is ended: encode, decode
              movb #0, Ctrl
              rti
cmdIpEnd:     mov (sp)+, r2
              mov (sp)+, r1
              rti

  ;;;;;;;;; FUNCTIONS CALLS: ;;;;;;;;;;;;

FUNCS:
chkEncode:    mov #CMDLINE, -(sp)
              jsr r2, cmpStr        ; checks if the given command is "encode"
              .ascii <encode&>
              .even
              mov (sp)+, r2         ; (sp)=OUTPUT 1/0
              cmp r2, #1
              beq chkDecode         ; if not "encode" than check if "decode"

        ;;;;;; ENCODE CALL:

              tst -(sp)
              mov #CMDLINE, -(sp)
              jsr pc, nextArgCmd      ; gets the next word seperated by " " in the given command
              tst (sp)+
              mov (sp)+, r2          ; r2 = first parameter address

              clr -(sp)
              mov r2, -(sp)           ; r2 = parameter's address
              jsr pc, prmToOcCmd      ; converts parameter from ascii to octal num
              tst (sp)+
              movb (sp)+, IMG3Rows

              tst -(sp)
              mov r2, -(sp)          ; r2 = first parameter address
              jsr pc, nextArgCmd    ; gets the next word seperated by " " in the given command
              tst (sp)+
              mov (sp)+, r2          ; r2 = second parameter address

              clr -(sp)
              mov r2, -(sp)           ; r2 = parameter's address
              jsr pc, prmToOcCmd      ; converts parameter from ascii to octal num
              tst (sp)+
              movb (sp)+, IMG3Cols

              ;mov #2, -(sp)
              ;jsr pc, setPrio        ; change priority level from 4 to 2
              ;tst (sp)+

              mov #encPrmt1, -(sp)    ; encPrmt1="Please enter image to encode"
              mov #1, -(sp)
              jsr pc, printText
              cmp (sp)+, (sp)+

              mov #IMG3Cols, COLSADR    ; init COLSADR and ROWSADR for imgInput to know
              mov #IMG3Rows, ROWSADR    ; dimentions the current given IMG

              ;;;;;;;;;;;;;;;;;;;;;;;;;
              mov #TEMPIMG, IMGIT         ; init IMG iterator
              movb #1, Ctrl               ; sets Ctrl symbolize encode proccess
              jmp cmdInpFinish            ; end interupt, next call will be at imgInput
              ;;;;;;;;;;;;;;;;;;;;;;;;;

                                          ; gets here when finished to get all bytes in the image
finEnc:       mov r3, -(sp)          ; environment safty
              mov r4, -(sp)
              clr r3
              clr r4
              movb IMG3Rows, r3
              movb IMG3Cols, r4

              ash #8, r3
              mov r3, -(sp)           ; r3=nRows
              movb r4, (sp)           ; r4=nCols
              mov sp, -(sp)           ; push nRows and nCols to stack and transfer the address of it to cmdEnc
              inc (sp)
              mov sp, -(sp)
              add #2, (sp)
              jsr pc, cmdEnc          ; start Encode proccess
              cmp (sp)+, (sp)+
              tst (sp)+

              ;mov #4, -(sp)
              ;jsr pc, setPrio        ; change priority level from 2 to 4
              ;tst (sp)+

              mov (sp)+, r4            ; restore registers from outside
              mov (sp)+, r3

              movb #-1, Ctrl           ; Ctrl=-1 when decode or encode in ended
              jmp clrFinishCmd

chkDecode:    mov #CMDLINE, -(sp)
              jsr r2, cmpStr            ; checks if the given command is "decode"
              .ascii <decode&>
              .even
              mov (sp)+, r2         ; (sp)=OUTPUT 1/0
              cmp r2, #1
              beq chkHash               ; if not, check if it is "Hash"

        ;;;;;; DECODE CALL

              tst -(sp)
              mov #CMDLINE, -(sp)
              jsr pc, nextArgCmd          ; gets the next word in the given command
              tst (sp)+
              mov (sp)+, r2          ; r2 = first parameter address

              clr -(sp)
              mov r2, -(sp)           ; r2 = parameter's address
              jsr pc, prmToOcCmd        ; converts the given parameter from ascii to octal num
              tst (sp)+
              movb (sp)+, IMG3Rows           ; r3 = nRows value

              tst -(sp)
              mov r2, -(sp)          ; r2 = first parameter address
              jsr pc, nextArgCmd    ; gets the next word in the given command
              tst (sp)+
              mov (sp)+, r2          ; r2 = second parameter address

              clr -(sp)
              mov r2, -(sp)           ; r2 = parameter's address
              jsr pc, prmToOcCmd        ; converts the given parameter from ascii to octal num
              tst (sp)+
              movb (sp)+, IMG3Cols           ; r4 = nCols value

              ;mov #2, -(sp)
              ;jsr pc, setPrio        ; change priority level from 4 to 2
              ;tst (sp)+

              mov #decPrmt1, -(sp)       ;  decPrmt1="Please enter image to decode"
              mov #1, -(sp)
              jsr pc, printText
              cmp (sp)+, (sp)+

              mov #IMG3Cols, COLSADR          ; init COLSADR and ROWSADR for imgInput
              mov #IMG3Rows, ROWSADR

              ;;;;;;;;;;;;;;;;;;;;;;;;;
              mov #TEMPIMG, IMGIT           ; init IMG iterator
              movb #2, Ctrl                 ; sets Ctrl symbolize decode proccess
              jmp cmdInpFinish              ; end interupt, next call will be at imgInput
              ;;;;;;;;;;;;;;;;;;;;;;;;;

                                    ; gets here when IMG is ready
finDec:       mov r3, -(sp)          ; environment safty
              mov r4, -(sp)
              clr r3
              clr r4
              movb IMG3Rows, r3
              movb IMG3Cols, r4

              ash #8, r3
              mov r3, -(sp)           ; r3=nRows
              movb r4, (sp)           ; r4=nCols
              mov sp, -(sp)
              inc (sp)
              mov sp, -(sp)
              add #2, (sp)
              jsr pc, cmdDec          ; pushed nRows and nCols by address in stack
              cmp (sp)+, (sp)+
              tst (sp)+

              ;mov #4, -(sp)
              ;jsr pc, setPrio        ; change priority level from 2 to 4
              ;tst (sp)+

              mov (sp)+, r4            ; restore registers from outside
              mov (sp)+, r3

              movb #-1, Ctrl           ; Ctrl=-1 when decode or encode in ended
              jmp clrFinishCmd

chkHash:      mov #CMDLINE, -(sp)
              jsr r2, cmpStr          ; checks if the given command is "setHash"
              .ascii <setHash&>
              .even
              mov (sp)+, r2         ; (sp)=OUTPUT 1/0
              cmp r2, #1
              beq chkKey              ; if not, than check if it is "setKey"

        ;;;;;; SETHASH CALL

              tst -(sp)
              mov #CMDLINE, -(sp)
              jsr pc, nextArgCmd      ; gets the next word in the given command line
              tst (sp)+
              mov (sp)+, r2          ; r2 = first parameter address

              mov r2, -(sp)          ; r2 = new Hash str address
              jsr pc, cmdSetHash      ; sets Hash label to the given Hash sequence
              tst (sp)+

              jmp clrFinishCmd

chkKey:       mov #CMDLINE, -(sp)
              jsr r2, cmpStr          ; chceks if the given command is "setKey"
              .ascii <setKey&>
              .even
              mov (sp)+, r2         ; (sp)=OUTPUT 1/0
              cmp r2, #1
              beq chkCrack          ; if not, than check if it is "crack"

        ;;;;;; SETKEY CALL

              tst -(sp)
              mov #CMDLINE, -(sp)
              jsr pc, nextArgCmd        ; gets the next word in the given command line
              tst (sp)+
              mov (sp)+, r2          ; r2 = first parameter address

              mov r2, -(sp)          ; r2 = new Key str address
              jsr pc, cmdSetKey       ; sets a linked list of nums in "KeyUse" label which represents a key sequence
              tst (sp)+

              jmp clrFinishCmd

chkCrack:     mov #CMDLINE, -(sp)
              jsr r2, cmpStr          ; checks if the given command is "crack"
              .ascii <crack&>
              .even
              mov (sp)+, r2         ; (sp)=OUTPUT 1/0
              cmp r2, #1
              bne pass3
              jmp chkPrint            ; if not, than check if it is "print"
pass3:

        ;;;;;; CRACK CALL

              tst -(sp)
              mov #CMDLINE, -(sp)
              jsr pc, nextArgCmd        ; gets the next word in the given command line
              tst (sp)+
              mov (sp)+, r2          ; r2 = first parameter address

              clr -(sp)
              mov r2, -(sp)           ; r2 = parameter's address
              jsr pc, prmToOcCmd        ; converts the parameter from ascii to octal num
              tst (sp)+
              movb (sp)+, IMG1Rows

              tst -(sp)
              mov r2, -(sp)          ; r2 = first parameter address
              jsr pc, nextArgCmd      ; gets the next word in the given command line
              tst (sp)+
              mov (sp)+, r2          ; r2 = second parameter address

              clr -(sp)
              mov r2, -(sp)           ; r2 = parameter's address
              jsr pc, prmToOcCmd       ; converts the parameter from ascii to octal num
              tst (sp)+
              movb (sp)+, IMG1Cols

              tst -(sp)
              mov r2, -(sp)          ; r2 = second parameter address
              jsr pc, nextArgCmd      ; gets the next word in the given command line
              tst (sp)+
              mov (sp)+, r2          ; r2 = third parameter address

              clr -(sp)
              mov r2, -(sp)           ; r2 = parameter's address
              jsr pc, prmToOcCmd       ; converts the parameter from ascii to octal num
              tst (sp)+
              movb (sp)+, KeyMaxSize

              mov #crkPrmt1, -(sp)      ; crkPrmt1="Please enter image"
              mov #1, -(sp)
              jsr pc, printText
              cmp (sp)+, (sp)+

              mov #IMG1Cols, COLSADR        ; init COLSADR and ROWSADR for imgInput
              mov #IMG1Rows, ROWSADR

              ;;;;;;;;;;;;;;;;;;;;;;;;;
              mov #TEMPIMG, IMGIT           ; init IMGIT iterator
              movb #3, Ctrl                 ; Ctrl=3 when the first IMG for crack need to be proccess
              jmp cmdInpFinish
              ;;;;;;;;;;;;;;;;;;;;;;;;;

finCrk1:      mov r5, -(sp)                 ; gets here when the first IMG is ready

              clr r5
              movb IMG1Cols, r5
              mov r4, -(sp)
              clr r4
              movb IMG1Rows, r4
              mul r4, r5                  ; calculates dimentions of IMG and stores it in r5
              mov (sp)+, r4

              mov r5, -(sp)             ; r5=dimenstions
              mov #IMG1, -(sp)
              jsr pc, parseImg          ; remove all irelevant data which has been given by user and stores data in IMG1
              cmp (sp)+, (sp)+

              mov r5, -(sp)             ; r5=dimenstions
              mov #IMG1, -(sp)          ; img to convert from asci to octal
              jsr pc, asciToOc          ; converts all data from ascii to octal nums
              cmp (sp)+, (sp)+

              mov (sp)+, r5

              mov #crkPrmt2, -(sp)        ; crkPrmt2="Please enter encoded image"
              mov #1, -(sp)
              jsr pc, printText
              cmp (sp)+, (sp)+

              ;;;;;;;;;;;;;;;;;;;;;;;;;
              mov #TEMPIMG, IMGIT         ; init IMG iterator
              movb #4, Ctrl               ; Ctrl=4 when the second IMG of crack need to be proccess
              mov #101, tks
              rti
              ;;;;;;;;;;;;;;;;;;;;;;;;;

finCrk2:      mov r5, -(sp)             ; gets here when second IMG is ready

              clr r5
              movb IMG1Cols, r5
              mov r4, -(sp)
              clr r4
              movb IMG1Rows, r4
              mul r4, r5                ; calculates dimentions of IMG and stores in r5
              mov (sp)+, r4

              mov r5, -(sp)             ; r5=dimenstions
              mov #IMG2, -(sp)
              jsr pc, parseImg          ; remove all irelevant data which has been given by user and stores data in IMG1
              cmp (sp)+, (sp)+

              mov r5, -(sp)             ; r5=dimenstions
              mov #IMG2, -(sp)          ; img to convert from asci to octal
              jsr pc, asciToOc          ; converts all data from ascii to octal nums
              cmp (sp)+, (sp)+

              mov r5, (sp)+

              mov #1, -(sp)
              jsr pc, setPrio        ; change priority level from 4 to 1 for enabling keboard to interupt
              tst (sp)+

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;; interuptions enable ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        mov #cmdPrmt, -(sp)           ; prints "$ "
        mov #newLinePrmt, -(sp)
        mov #2, -(sp)
        jsr pc, printText
        cmp (sp)+, (sp)+
        tst (sp)+

        movb #0, Ctrl                 ; init Ctrl to start getting new commands while finding Key
        mov #TEMPCMD, CMDIT           ; init CMD iterator to start
        mov #101, tks                 ; turns keyboard interuptions while finding a key
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

              mov r2, -(sp)          ; environment safty
              mov r4, -(sp)
              mov r5, -(sp)
              clr r2
              clr r4
              clr r5
              movb IMG1Rows, r2
              movb IMG1Cols, r4
              movb KeyMaxSize, r5

              ash #8, r2
              mov r2, -(sp)           ; r2=nRows
              movb r4, (sp)           ; r4=nCols
              mov r5, -(sp)           ; r5=key's max size
              mov sp, -(sp)
              add #3, (sp)
              mov sp, -(sp)
              add #4, (sp)
              jsr pc, cmdCrack          ; pushed nRows and nCols by address in stack
              cmp (sp)+, (sp)+
              cmp (sp)+, (sp)+

              mov #4, -(sp)
              jsr pc, setPrio        ; restore priority level from 1 to 4 after a key has been found
              tst (sp)+

              mov (sp)+, r5           ; restore registers from outside
              mov (sp)+, r4
              mov (sp)+, r2

              cmpb Ctrl, #0           ; checks the correct state of the program if it is getting an image or a command
              bne cont1
dollar:       bit #200, tps           ; if a command than print "$ " and all the privous given chars
              beq dollar
              mov #'$, tpb
space:        bit #200, tps
              beq space
              mov #40, tpb
              mov r1, -(sp)
              mov r2, -(sp)
              mov CMDIT, r1
              mov #TEMPCMD, r2
cmdCont1:     cmp r1, #TEMPCMD
              beq cmdCont2
prin:         bit #200, tps
              beq prin
              movb (r2)+, tpb
              dec r1
              br cmdCont1
cmdCont2:     mov (sp)+, r2
              mov (sp)+, r1
              mov #101, tks
              rti

cont1:        mov r1, -(sp)           ; if an image than prints all the privious given chars
              mov r2, -(sp)
              mov IMGIT, r1
              mov #TEMPIMG, r2
cont2:        cmp r1, #TEMPIMG
              beq cont3
print:        bit #200, tps
              beq print
              movb (r2)+, tpb
              dec r1
              br cont2
cont3:        mov (sp)+, r2
              mov (sp)+, r1
              mov #101, tks
              rti

chkPrint:     mov #CMDLINE, -(sp)
              jsr r2, cmpStr            ; checks if the given command is "print"
              .ascii <print&>
              .even
              mov (sp)+, r2         ; (sp)=OUTPUT 1/0
              cmp r2, #1
              beq chkQuit

        ;;;;;; PRINT CALL

              movb IMG3Cols, -(sp)
              movb IMG3Rows, -(sp)
              jsr pc, cmdPrint          ; prints IMG3 label - last encode or decode call
              cmp (sp)+, (sp)+

              jmp clrFinishCmd

chkQuit:      mov #CMDLINE, -(sp)
              jsr r2, cmpStr            ; checks if the given command is "quit"
              .ascii <quit&>
              .even
              mov (sp)+, r2         ; (sp)=OUTPUT 1/0
              cmp r2, #1
              beq chkFail               ; if not, than it is an UNknown command

        ;;;;;; QUIT CALL

              mov #quitPrmt, -(sp)        ;quitPrmt="Goodbye!"
              mov #1, -(sp)
              jsr pc, printText
              mov #main, sp
              jmp finish

        ;;;;;; UNKNOWN COMMAND

chkFail:      mov #dotPrmt, -(sp)           ; gets here when an Unknow command has been given
              mov #CMDLINE, -(sp)
              mov #unknownPrmt, -(sp)
              mov #3, -(sp)
              jsr pc, printText
              cmp (sp)+, (sp)+
              cmp (sp)+, (sp)+
              jmp clrFinishCmd

;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

cmdEnc: ; 2(sp) - nCols, 4(sp) - nRows
; gets by stack nCols and nRows address and turns
; encryptes an image which stored in IMG3 label and prints the result

      mov r5, -(sp)

      clr r5
      movb @4(sp), r5         ; 4(sp) = nCols
      mov r4, -(sp)
      clr r4
      movb @10(sp), r4    ; 10(sp) = nRows
      mul r4, r5
      mov (sp)+, r4

      ;;;;;;;;;;;;;;;;;;;;; input was here

      ;;;;;;;;;;;;;;;;;;;;; input was here

      mov r5, -(sp)             ; r5=dimenstions
      mov #IMG3, -(sp)
      jsr pc, parseImg          ; remove all irelevant data and transfer it from TEMPIMG to IMG3
      cmp (sp)+, (sp)+

      mov r5, -(sp)             ; r5=dimenstions
      mov #IMG3, -(sp)          ; img to convert from asci to octal
      jsr pc, asciToOc          ; converts IMG3 from ascii to octal nums
      cmp (sp)+, (sp)+

      mov #IMG3, -(sp)
      mov 10(sp), -(sp)            ; 10(sp)=nRows address
      mov 10(sp), -(sp)            ; 10(sp)=nCols address
      mov #Hash, -(sp)
      mov #KeyUse, -(sp)
      jsr pc, encode                ; encodes IMG3 and stores the result ing IMG3
      add #12, sp

      mov #encPrmt2, -(sp)          ;encPrmt2="The encoded image is:"
      mov #1, -(sp)
      jsr pc, printText
      cmp (sp)+, (sp)+

      mov #IMG3, -(sp)
      movb @10(sp), -(sp)            ; 10(sp) = nRows
      clr -(sp)
      movb @12(sp), (sp)            ; 12(sp) = nCols
      jsr pc, printImg              ; prints IMG3
      cmp (sp)+, (sp)+
      tst (sp)+

mov (sp)+, r5
rts pc

;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

imgInput: ; using IMGIT for chars iterator on TEMPIMG
; this is the sub input program which called by branch from cmdInput
; when Ctrl is 1,2,3,4 which represents where to imgInput has been called
; this subrutine proccessed an image char by char and does "rti" afterwards
; all chars stores in TEMPIMG label

      mov r1, -(sp)
      mov r2, -(sp)
      mov r5, -(sp)

      clr r5
      movb @COLSADR, r5
      mov r4, -(sp)
      clr r4
      movb @ROWSADR, r4
      mul r4, r5              ; calculates image dimenstions and stores it in r5
      mov (sp)+, r4

      clr r1
      movb tkb, r1

              cmp r1, #'\b
              bne imgInpEnter
              cmp IMGIT, #TEMPIMG      ; IMGIT=dymanic Img's addres
              beq imgInpFinish
              mov IMGIT, r2          ; IMGIT=dymanic Img's addres
              cmpb -(r2), #'\r
              beq imgInpFinish
              dec IMGIT
              movb #0, @IMGIT       ; IMGIT=dymanic Img's Address
              br imgInpPrint

imgInpEnter:  cmp r1, #'\r        ; is Enter?
              bne imgInpUpdate
              tst -(sp)               ; OUTPUT
              mov IMGIT, -(sp)       ; r3=dynamic Img address
              mov #TEMPIMG, -(sp)
              jsr pc, imgInpCount       ; Counts if num of relevant chars is bigger than image dimentions
              cmp (sp)+, (sp)+
              mov (sp)+, r2
              cmp r2, r5        ; r5=dimensions
              blo imgPrintLF            ; if not, then continue stores char in TEMPIMG
              ;;;;;;;;;;;;;;;;;;;;;;;;;;;
              mov (sp)+, r5               ; gets here when finished gets chars for the image
              mov (sp)+, r2
              mov (sp)+, r1
              cmpb #1, Ctrl
              bne pass4
              jmp finEnc          ; if was called from encode then finish encode function
pass4:        cmpb #2, Ctrl
              bne pass5
              jmp finDec          ; is was called from decode then finish decode function
pass5:        cmpb #3, Ctrl
              bne pass6
              jmp finCrk1           ; if was called from the first section of crack function, then run the second part
pass6:        jmp finCrk2       ; Ctrl=4, if was called from the second section of crack function, then run the last part of it
              ;;;;;;;;;;;;;;;;;;;;;;;;;;;
imgPrintLF:   bit #200, tps       ; if the image isnt ready then prints new line and continue
              beq imgPrintLF
              mov #'\n, tpb
              br imgInpUpdate

imgInpUpdate: movb r1, @IMGIT     ; IMGIT=Img's address
              inc IMGIT           ; stores the given char in TEMPCMD current pointer and increase it the point the next byte
              br imgInpPrint

imgIpBS1:     mov #40, r1         ; 40=" "
              bit #200, tps
              beq imgIpBS1
              mov r1, tpb
imgIpBS2:     mov #'\b, r1        ; if Backspace has been given then print \b then " " then \b again
              bit #200, tps
              beq imgIpBS2
              mov r1, tpb
              br imgInpFinish
imgInpPrint:  bit #200, tps
              beq imgInpPrint
              mov r1, tpb
              cmp r1, #'\b
              bne imgInpFinish
              br imgIpBS1

imgInpFinish: mov #101, tks       ; gets here when need to continue gets chars for the image
imgIpEnd:     mov (sp)+, r5       ; gets here when an image is ready
              mov (sp)+, r2
              mov (sp)+, r1
              rti

imgInpCount: ; 2(sp) - start addres, 4(sp) - end address, 6(sp) - OUTPUT
; this subrutine used by imgInput to count how much relevant chars have been given until the last Enter
; the OUTPUT is stored in stack

      mov r0, -(sp)
      mov r1, -(sp)

      mov 6(sp), r0             ; 6(sp) - start address
      clr r1                    ; r1 counts relevant chars in the image

countCont:
countChar:  cmpb (r0), #141     ; checks if the current char is between "a" to "f"
            blo countNum
            cmpb (r0), #146
            bhi countNum
            br countTrue

countNum:   cmpb (r0), #60        ; checks if the current char is between "0" to "9"
            blo countFalse
            cmpb (r0), #71
            bhi countFalse
            br countTrue

countTrue:  inc r1                ; gets here when a valid char is found
countFalse: inc r0                ; gets here when a irelevant char is found
            cmp 10(sp), r0      ; 10(sp) - end address
            bhi countCont         ; if finished to analize all chars from start, then finish subrutine

countFinish:  mov r1, 12(sp)    ; 12(sp) - OUTPUT
              mov (sp)+, r1
              mov (sp)+, r0
              rts pc
;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

; receives the following stack:
; return address
; amount of rows
; amount of columns

cmdPrint: cmp 2(sp), #0
          bne cont10
          cmp 4(sp), #0
cont10:   bne cont11
          rts pc

cont11:   mov 2(sp), -(sp)
          mov 6(sp), -(sp)
          mov r1, -(sp)         ;IMG iterator
          mov #IMG3, r1
          bit #1, @#tps
PstepCol:
          mov #1, -(sp)
          mov r1, -(sp)
          jsr pc, asciToOc        ;converts the byte into ascii
          cmp (sp)+, (sp)+
Pbusy_wait: tstb @#tps
          bpl Pbusy_wait
          cmpb (r1), #10
          bge Pprintstar
          movb #' , @#tpb        ;prints the byte in the IMG
          br Pcont
Pprintstar:
          movb #'*, @#tpb

Pcont:    mov #1, -(sp)
          mov r1, -(sp)
          jsr pc, ocToAsci        ;converts it back to octal
          cmp (sp)+, (sp)+
          inc r1
          dec 2(sp)
          bne PstepCol
Pnewline:tstb @#tps              ;prints newline
          bpl Pnewline
          movb #'\n, @#tpb
Pnewcrline:
          tstb @#tps
          bpl Pnewcrline
          movb #'\r, @#tpb

          mov 12(sp), 2(sp)
          dec 4(sp)               ;continues to the next line
          bne PstepCol

          mov (sp)+, r1
          cmp (sp)+, (sp)+
          rts pc

;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

cmdCrack: ; 2(sp) - nCols , 4(sp) - nRows, 6(sp) - key's max size

      mov r5, -(sp)

      clr r5
      movb @4(sp), r5         ; 4(sp) = nCols
      mov r4, -(sp)
      clr r4
      movb @10(sp), r4    ; 10(sp) = nRows
      mul r4, r5
      mov (sp)+, r4

      mov 10(sp), -(sp)         ; 10(sp)=key's max size
      jsr pc, crkGenKey         ; gets max key size and generate a matched linked list for crack proccess
      tst (sp)+

      mov #IMG1, -(sp)
      mov #IMG2, -(sp)
      mov 12(sp), -(sp)          ; 12(sp)=nRows
      mov 12(sp), -(sp)          ; 12(sp)=nCols
      mov #Hash, -(sp)
      jsr pc, crkSystem           ; call crack function to find a matched key for encode IMG1 to IMG3
      add #12, sp

      tst -(sp)
      jsr pc, keyToStr            ; converts key linked list to key sequence and stores it in KeyStr label
      mov (sp)+, r5          ; r5=key str length

      mov r5, -(sp)               ; r5=key str length
      mov #KeyStr, -(sp)          ; KeyStr to convert from octal to ascii
      jsr pc, ocToAsci
      cmp (sp)+, (sp)+

      mov #newLinePrmt, -(sp)
      mov #KeyStr, -(sp)
      mov #crkPrmt3, -(sp)          ; prints the key that has been found in crack proccess
      mov #3, -(sp)
      jsr pc, printText
      cmp (sp)+, (sp)+
      cmp (sp)+, (sp)+

mov (sp)+, r5
rts pc

;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

keyToStr: ; 2(sp) - OUTPUT key str length
; this subrutine converts key's linked list to string which in Key label and stores it in Keystr

      mov r0, -(sp)
      mov r1, -(sp)
      mov r2, -(sp)

              mov #Key, r0
              mov #KeyStr, r1
              clr r2

keyStrPrcs:   cmp (r0), #-1
              beq keyStrFinish
              movb (r0), (r1)+
              inc r2
              tst (r0)+
              cmp (r0), #0
              beq keyStrFinish
              mov (r0), r0              ; r0 gets the next node by address and continue converting
              br keyStrPrcs

keyStrFinish: movb #'&, (r1)
              mov r2, 10(sp)        ; 10(sp)=OUTPUT
              mov (sp)+, r2
              mov (sp)+, r1
              mov (sp)+, r0
              rts pc

;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

nextKey: ; r1=key
; nextKey subrutine:
; changes a given key by r1 to the next key in cyclic Order
; parameter is given by r1
              mov r1, -(sp)           ; saves list's head

nkCheckKey:   cmp (r1), #17           ; checks if "17-17-17-..."
              blt nkStart             ; if false then start calculate the next key
              add #2, r1
              tst (r1)
              beq nkFinish            ; if true then do nothing
              mov (r1), r1
              br nkCheckKey

nkStart:      mov (sp)+, r1           ; restors list's head
nkIncNode:    cmp (r1), #17
              bge nkNextNode          ; if reach 17 in the current node then move to the next node

              inc (r1)                ; otherwise, increase the current node and exit
              br nkFinish

nkNextNode:   clr (r1)
              add #2, r1
              mov (r1), r1
              br nkIncNode            ; continue calculate the next key

nkFinish:     rts pc

;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

cmpImg: ; 2(sp)=OUTPUT , 4(sp)=nCols , 6(sp)=nRows , 10(sp)=Img2, 12(sp)=Img1
; cmpImg subrutine:
; returns "0" by sp if the given 2 Imgs is equal, otherwise returns "1"
; all parameters are given by sp

              mov r1, -(sp)         ; saves r1,r2,r3,r4 for internal usage
              mov r2, -(sp)
              mov r3, -(sp)
              mov r4, -(sp)

              mov 20(sp), r1       ; moves Img1 to r1
              mov 16(sp), r2        ; moves Img2 to r1

cmpByte:      cmpb (r1), (r2)
              bne cmpFalse            ; if [(r1) == (r2)] then return false

              clr r3
              movb @12(sp), r3        ; moves nRows to r2
              movb @14(sp), r4        ; moves nCols to r3
              mul r4, r3              ; r3=nCols*nRows

              add 20(sp), r3          ; 20(sp)=Img1
              dec r3
              cmp r3, r1
              ble cmpTrue             ; if r1 reached the end of Img then return true

              inc r1
              inc r2
              br cmpByte              ; continues check the next byte

cmpFalse:     mov #1, 22(sp)           ; reaches here when a difference between 2 bytes was found
              br cmpFinish

cmpTrue:      mov #0, 22(sp)           ; reaches here when all bytes are equal each other
              br cmpFinish

cmpFinish:    mov (sp)+, r4           ; restores all registers
              mov (sp)+, r3
              mov (sp)+, r2
              mov (sp)+, r1
              rts pc

;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

crkSystem: ; 2(sp)=Hash , 4(sp)=nCols , 6(sp)=nRows , 10(sp)=EncImg , 12(sp)=OrigImg , Key=OUTPUT
; crkSystem subrutine:
; returns a matched key by global variable for a given OrigImg and EncImg
; all parameters are given by sp

          mov r1, -(sp)         ; saves r1's value

          tst -(sp)             ; output space
          mov 16(sp), -(sp)     ; 16(sp)=OrigImg
          mov 16(sp), -(sp)     ; 16(sp)=EncImg
          mov 16(sp), -(sp)     ; 16(sp)=nRows
          mov 16(sp), -(sp)     ; 16(sp)=nCols
          jsr pc, cmpImg
          add #10, sp

          tst (sp)+
          bne sysFind         ; checks if EncImg == OrigImg
          mov #Key, r1
          jsr pc, nextKey
          br sysFinish

sysFind:  mov #Key, r1
          jsr pc, nextKey

          mov 14(sp), -(sp)     ; 14(sp)=OrigImg
          mov 12(sp), -(sp)     ; 12(sp)=nRows
          mov 12(sp), -(sp)     ; 12(sp)=nCols
          mov 12(sp), -(sp)     ; 12(sp)=Hash
          mov #Key, -(sp)
          jsr pc, encode        ; encoding for comparison
          add #12, sp

          tst -(sp)             ; output space
          mov 16(sp), -(sp)     ; 16(sp)=OrigImg
          mov 16(sp), -(sp)     ; 16(sp)=EncImg
          mov 16(sp), -(sp)     ; 16(sp)=nRows
          mov 16(sp), -(sp)     ; 16(sp)=nCols
          jsr pc, cmpImg
          add #10, sp

          tst (sp)+
          beq sysFinish         ; checks if EncImg == OrigImg

          mov 14(sp), -(sp)     ; 14(sp)=OrigImg
          mov 12(sp), -(sp)     ; 12(sp)=nRows
          mov 12(sp), -(sp)     ; 12(sp)=nCols
          mov 12(sp), -(sp)     ; 12(sp)=Hash
          mov #Key, -(sp)
          jsr pc, decode        ; decoding OrigImg after encryption
          add #12, sp

          br sysFind            ; continues check the next key

sysFinish:    mov (sp)+, r1     ; restores r1 value
              rts pc

;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

crkGenKey:  mov r1, -(sp)
            mov r2, -(sp)
            mov #Key, r1      ;iterator for node's value
            mov #Key, r2      ;iterator for next node
            add #4, r2

CgenNext:   mov #1, (r1)      ;initializes the value to be -1
            neg (r1)
            add #2, r1
            mov r2, (r1)      ;sets next node to be r2's value
            add #4, r2
            add #2, r1
            dec 6(sp)
            bne CgenNext
            sub #2, r1
            mov #0, (r1)
            mov (sp)+, r2
            mov (sp)+, r1
            rts pc

;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

cmdSetKey:; 2(sp) - #strKey

      mov r0, -(sp)
      mov r1, -(sp)
      mov r2, -(sp)

      mov 10(sp), r0               ; 10(sp)=#strKey
      mov #-1, r1

keyGetSize: inc r1
      cmpb (r0)+, #'&
      bne keyGetSize

      cmp r1, #0
      beq keyFinish

      mov r1, -(sp)                ; r1=length
      mov 12(sp), -(sp)            ; 12(sp)=#strKey
      jsr pc, asciToOc
      cmp (sp)+, (sp)+

      mov #KeyUse, r0
      mov 10(sp), r2                ; 10(sp)=#strKey

keyCreateList:
      cmpb #'&, (r2)
      beq setKeySucces ; change
      movb (r2)+, (r0)
      add #2, r0
      mov r0, (r0)
      add #2, (r0)+
      br keyCreateList

setKeySucces:
      mov #0, -(r0)           ; puts "NIL" at the end of the list

      mov r1, -(sp)             ; r1=length
      mov 12(sp), -(sp)         ; 12(sp)=#strKey
      jsr pc, ocToAsci
      cmp (sp)+, (sp)+

      mov #newLinePrmt, -(sp)
      mov 12(sp), -(sp)         ; 10(sp)=#strKey
      mov #setKeyPrmp, -(sp)
      mov #3, -(sp)
      jsr pc, printText
      add #10, sp

keyFinish:
      mov (sp)+, r2
      mov (sp)+, r1
      mov (sp)+, r0
rts pc

;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

; this function received the stack in the following order:
; return address
; address pointing to hash
cmdSetHash:   mov #20, -(sp)
              mov 4(sp), -(sp)
              jsr pc, asciToOc    ;convert Hash to octal
              cmp (sp)+, (sp)+

              mov r2, -(sp)
              mov r3, -(sp)
              mov #20, -(sp)
              mov #Hash, r2
              mov 10(sp), r3
SHupdateHash: movb (r3)+, (r2)+
              dec (sp)
              bne SHupdateHash
              tst (sp)+
              mov (sp)+, r2
              mov (sp)+, r3

              mov #20, -(sp)
              mov 4(sp), -(sp)
              jsr pc, ocToAsci    ;convert Hash to octal
              cmp (sp)+, (sp)+

              mov #SHend, -(sp)
              mov 4(sp), -(sp)    ;push the converted Hash
              mov #SHstr, -(sp)
              mov #3, -(sp)       ; "Hash function set to" + <Hash> + "\n\r"
              jsr pc, printText
              cmp (sp)+, (sp)+
              cmp (sp)+, (sp)+
              rts pc
SHstr:        .ascii        <Hash function set to &>
SHend:        .ascii        <\n\r&>
.even

;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

cmdDec: ; 2(sp) - nCols, 4(sp) - nRows

      mov r5, -(sp)

      clr r5
      movb @4(sp), r5         ; 4(sp) = nCols
      mov r4, -(sp)
      clr r4
      movb @10(sp), r4    ; 10(sp) = nRows
      mul r4, r5              ; calculates image dimenstions and stores it in r5
      mov (sp)+, r4

      mov r5, -(sp)             ; r5=dimenstions
      mov #IMG3, -(sp)
      jsr pc, parseImg            ; removes all ireleveant data and stores it in IMG3 label
      cmp (sp)+, (sp)+

      mov r5, -(sp)             ; r5=dimenstions
      mov #IMG3, -(sp)          ; img to convert from asci to octal
      jsr pc, asciToOc
      cmp (sp)+, (sp)+

      mov #IMG3, -(sp)
      mov 10(sp), -(sp)            ; 10(sp)=nRows address
      mov 10(sp), -(sp)            ; 10(sp)=nCols address
      mov #Hash, -(sp)
      mov #KeyUse, -(sp)
      jsr pc, decode                ; decode the given image and stores the result in the same label
      add #12, sp

      mov #decPrmt2, -(sp)          ; decPrmt2="The decoded image is:"
      mov #1, -(sp)
      jsr pc, printText
      cmp (sp)+, (sp)+

      mov #IMG3, -(sp)
      movb @10(sp), -(sp)            ; 10(sp) = nRows
      clr -(sp)
      movb @12(sp), (sp)            ; 12(sp) = nCols
      jsr pc, printImg               ; prints the result in Hexa chars
      cmp (sp)+, (sp)+
      tst (sp)+

mov (sp)+, r5
rts pc

;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

;this procedure decodes an image.
;output - the OrigImg
decode:   ; 2(sp) - key, 4(sp) - hash, 6(sp) - nCols, 10(sp) - nRows, 12(sp) - OrigImg
          ; reveives the stack in the following way:
          ; push OrigImg
          ; push nRows
          ; push nCols
          ; push Hash
          ; push Key
          mov 12(sp), -(sp)         ;store the EncImg pointer, so we can update it we the work on the current block
          mov r5, -(sp)
          clr r5
          ;Decodes the whole block. i.e: encrypts it, unmixes it, then encrypts it again
DecodeBlock: mov 2(sp), -(sp)
          mov 10(sp), -(sp)
          mov 16(sp), -(sp)
          jsr pc, DecryptBlock
          tst (sp)+
          tst (sp)+
          tst (sp)+
          mov 2(sp), -(sp)
          mov 12(sp), -(sp)
          mov 16(sp), -(sp)
          jsr pc, UnmixBlock
          tst (sp)+
          tst (sp)+
          tst (sp)+
          mov 2(sp), -(sp)
          mov 10(sp), -(sp)
          mov 16(sp), -(sp)
          clr r5
          jsr pc, DecryptBlock
          tst (sp)+
          tst (sp)+
          tst (sp)+

          ;calculate if we bypassed the user's limit for the image

          mov r4, -(sp)       ;use r4 as a temp var for mul
          mov r3, -(sp)       ;use r3 as a temp var for mul
          clr r3
          movb @16(sp), r4    ;copy nCols
          mov 16(sp), r3      ;copy nRows
          inc r3
          movb (r3), r3
          mul r4, r3          ;we know the image size is less then 2^16
          mov r3, r4
          add 22(sp), r4      ; 22(sp) is the place where encode got OriImg address
          sub r5, r4          ;if we exceeded the blocks - should be negative
          tst r4
          bmi DMoveBlockRight
          tst r4
          bne CompBlockDown
          ; move to the next block from the right. i.e: adds 4 bytes to the columns
DMoveBlockRight:
          sub r3, r5          ;initialize the OrigImg pointer to the first line in the column.
          mov r5, 6(sp)       ;basically we substract the multiplication of nColsxnRows from the current
                              ;place in the image's pointer (stored in 2(sp))
          add #4, 6(sp)       ;move to next block from right
          mov 6(sp), r4
          clr r3
          movb @16(sp), r3    ;copy nCols value to r3
          sub r3, r4
          mov 22(sp), r3
          sub r4, r3
          beq DEndDecodeRight     ;if the result=0, we exceeded nCols

          mov (sp)+, r3
          mov (sp)+, r4
          br DecodeBlock
          ;moves to the next block from the bottom. i.e: adds 4 rows.
CompBlockDown:
          mov (sp)+, r3
          mov (sp)+, r4
          mov r5, 2(sp)
          br DecodeBlock
          br FinishDecode
DEndDecodeRight:
          mov (sp)+, r3
          mov (sp)+, r4
FinishDecode:
          mov (sp)+, r5
          tst (sp)+           ;pull the r5 we pushed earlier to return r1's value from the encription
          rts pc

          ; the encryption for the block. uses xor encryption with the users key.
DecryptBlock:  ; 14(sp) - nCols address, 16(sp) - Key address, 20(sp) - OImg address
               ; Order of passing parameters:
               ; push Image address
               ; push Key address
               ; push nCols address
          mov r1, -(sp)
          mov r2, -(sp)
          mov r4, -(sp)
          mov r5, -(sp)
          mov r3, -(sp)
          clr r4
          mov 20(sp), r1
          mov 16(sp), r2
          mov @14(sp), r4
          bic #177400, r4                 ;gets lower byte of r4, which is nCols
          mov #4, r5                      ;set counters for sob
          mov #4, r3
          ;decrypts a line
DecryptLine:
          mov r2,-(sp)                    ;store current node and put it's value in r2
          mov (r2),r2
          mov r1,-(sp)                    ;because r1 is byte, we store r1's address and move into it the value for xoring
          clr r1
          movb @0(sp), r1
          xor r2,r1
          movb r1, @0(sp)
          mov (sp)+, r1
          inc r1
          mov (sp)+, r2
          add #2, r2                       ;moves to next node in key
          cmp @(r2), #177777
          beq DGetNewKey                    ;cycles again the key if nil
          tst(r2)
          bne DKeyLenIsOk
          ;set the first key value if the current one is -1 or nil
DGetNewKey:
          mov 16(sp), r2
          sob r5, DecryptLine
          br DNextLine
DKeyLenIsOk: mov (r2), r2                    ;get address of new key node
          sob r5, DecryptLine
          ;continue to the next line
DNextLine: sub #4, r1                       ;mov r1 to the beginning of line
          add r4, r1                      ;moves r4 one line forward
          mov #4, r5
          sob r3, DecryptLine
          mov (sp)+, r3
          mov (sp)+, r5
          mov r1, r5
          mov (sp)+, r4
          mov (sp)+, r2
          mov (sp)+, r1
          rts pc
          ;un-mixes the block. Using the Img's value in order to get the index in the Hash Function.
UnmixBlock: ; 14(sp) - nCols address, 16(sp) - Hash address, 20(sp) - OImg address
           ; Order of passing parameters:
           ; push Image address
           ; push Hash address
           ; push nCols address
          mov r1, -(sp)
          mov r2, -(sp)
          mov r4, -(sp)
          mov r5, -(sp)
          mov r3, -(sp)
          clr r4
          mov 20(sp), r1
          mov 16(sp), r2
          mov @14(sp), r4
          bic #177400, r4
          mov #4, r5
          mov #4, r3
          mov #4, -(sp)       ; counter for cyclic move
          ; unmixes a line in a block
LineUnmix:
          mov r2, -(sp)
          mov r1, -(sp)       ; stores r1-index to img, r2-index to hash
          mov r3, -(sp)       ;temp iterator for Hash array
          clr r3
          movb (r1), r1
          ;calculates an index in the Hash function, for a gives byte in the image in order to restore it's initial value.
DCalculateIndex:                     ;goes over Hash values until it matches (r1)
          cmpb r1, (r2)+
          beq IndexFound
          inc r3
          br DCalculateIndex
IndexFound:
          movb r3, @2(sp)
          inc 2(sp)
          mov (sp)+, r3
          mov (sp)+, r1
          mov (sp)+, r2
          sob r3, LineUnmix
          sub #4, r1          ; initialize r1 to points to the first element in line

          mov r5,(sp)         ;r5 = 4 in the beginning
          ;sub #4, (sp)        ;checks if cyclic move needs to be taken and how many moves should be done
          ;neg (sp)
          cmp (sp), #4
          beq DNextRow
          mov r5, -(sp)       ;use r5 as counter for cyclic moves
          mov r3, -(sp)       ;use r3 as a temp register
          ;cyclic move operation
DCyclicRep:
          clr r3
          mov #3, r5
          add #3, r1          ;r1 should point to the last element in line
          movb (r1), r3

DCyclicLineOp:
          dec r1              ;move the value of (r1) to the next byte
          movb (r1), 1(r1)
          dec r5
          bne DCyclicLineOp          ;if finished the cyclic move, continue
          movb r3, (r1)
          dec 4(sp)
          bne DCyclicRep        ;if finished cyclic operation on the line, continue
          mov (sp)+, r3
          mov (sp)+, r5
DNextRow:
          add r4, r1
          mov #4, r3
          sob r5, LineUnmix
          tst (sp)+
          mov (sp)+, r3
          mov (sp)+, r5
          mov (sp)+, r4
          mov (sp)+, r2
          mov (sp)+, r1
          rts pc

;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

; The state of the stack when enters the proc:
; return address
; priority level
; this subrutine changes the program priority level for enableing interupts

setPrio:  mov r1, -(sp)
          mov 4(sp), r1
          ash #5, r1

          mov (sp), -(sp)
          mov 4(sp), 2(sp)
          mov r1, 4(sp)

          mov (sp)+, r1
          rti

;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

; Recevies the following stack:
; return address
; number string
; empty space for octal num
; this subrutine gets a string by address and converts it to ocatal num
; the given string represents an octal number
prmToOcCmd: mov r1, -(sp)     ;string iterator
            mov r3, -(sp)
            mov #10, -(sp)
            mov 10(sp), r1

prmLoop:    clr r3
            movb (r1), r3
            sub #60, r3
            add r3, 12(sp)
            inc r1
            cmpb   (r1), #'&
            beq prmFinish
            dec r1
            mov 12(sp), r3
            mul (sp), r3
            mov r3, 12(sp)
            inc r1
            br prmLoop
prmFinish:
            tst (sp)+
            mov (sp)+, r3
            mov (sp)+, r1
            rts pc

;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

; this subrutine gets an address for sroing data and removes all irelevant chars
; all data is transfered to the given address without illegal chars

parseImg: mov r1,-(sp)          ; valid Img iterator
          mov r2, -(sp)         ; temp image terator
          mov 6(sp), r1
          mov #TEMPIMG, r2
PIloop:   clr -(sp)
          movb (r2), (sp)
          clr -(sp)             ; 1/0 if is in charset
          jsr pc, isValidHex
          cmpb (sp), #1
          beq copyChar
          inc r2
          cmp (sp)+, (sp)+
          bne PIloop
copyChar: movb (r2)+, (r1)+
          clr (sp)
          cmp (sp)+, (sp)+
          dec 10(sp)
          bne PIloop

          mov (sp)+, r2
          mov (sp)+, r1
          rts pc
; stack overview:
; return addresses
; blank space
; char to be checked
isValidHex: mov r1, -(sp)       ;charset iterator
            mov #charSet, r1
nextChar:   cmpb (r1), 6(sp)
            beq validFinish
            cmpb (r1), #'&
            beq notCharset
            inc r1
            br nextChar
validFinish: mov #1, 4(sp)
notCharset:  mov (sp)+, r1
             rts pc

.even
charSet: .ascii<0123456789abcdef&>
.even

;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

asciToOc:; 2(sp) - #str , 4(sp) - size
; this subrutine gets by stack an address of string and its size
; the given string represent hexa digits
; all hexa digit are converted to octal codes

      mov r1, -(sp)
      mov r2, -(sp)
      mov r3, -(sp)

      mov 10(sp), r1           ; 10(sp)=#str
      mov 12(sp), r3          ; 12(sp)=length

toOcProcess:
      movb (r1), r2
      mov r2, -(sp)
      bic #777637, r2
      cmp r2, #140            ; is char?
      beq ocChar
ocNum:  mov (sp)+, r2         ; gets here when the current digit is a num
        bic #777760, r2
        br ocUpdate
ocChar: mov (sp)+, r2         ; gets here when the current digit is a char
        bic #777770, r2
        add #11, r2

ocUpdate:   movb r2, (r1)+    ; converts from ascii to octal
            dec r3
            beq toOcFinish
            br toOcProcess

toOcFinish: mov (sp)+, r3
            mov (sp)+, r2
            mov (sp)+, r1
            rts pc

;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

; receives the following stack:
; return address
; amount of COLUMNS
; amount of ROWS
; Img address
; output:
; prints the image in HEX format

printImg: mov 4(sp), -(sp)
          mov 4(sp), -(sp)
          mov r1, -(sp)         ;IMG iterator
          mov 14(sp), r1
          bit #1, @#tps
PIstepCol:
          mov #1, -(sp)
          mov r1, -(sp)
          jsr pc, ocToAsci        ;converts the byte into ascii
          cmp (sp)+, (sp)+
PIbusy_wait: tstb @#tps
          bpl PIbusy_wait
          movb (r1), @#tpb        ;prints the byte in the IMG
          mov #1, -(sp)
          mov r1, -(sp)
          jsr pc, asciToOc        ;converts it back to octal
          cmp (sp)+, (sp)+
          inc r1
          dec 2(sp)
          bne PIstepCol
PInewline:tstb @#tps              ;prints newline
          bpl PInewline
          movb #'\n, @#tpb
PInewcrline:
          tstb @#tps
          bpl PInewcrline
          movb #'\r, @#tpb

          mov 10(sp), 2(sp)
          dec 4(sp)               ;continues to the next line
          bne PIstepCol

          mov (sp)+, r1
          cmp (sp)+, (sp)+
          rts pc

;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

ocToAsci:; 2(sp) - #str , 4(sp) - size
  ; this subrutine gets by stack an address of string and its size
  ; the given string represent octal code
  ; all octal codes are converted to ascii codes which represents hexa digits

      mov r1, -(sp)
      mov r2, -(sp)
      mov r3, -(sp)

      mov 10(sp), r1           ; 10(sp)=#str
      mov 12(sp), r3          ; 12(sp)=length

toAsciProcess:
          movb (r1), r2
          cmp r2, #12            ; is char?
          bge asciChar
asciNum:  bis #60, r2
          br asciUpdate
asciChar: bis #140, r2
          sub #11, r2

asciUpdate:   movb r2, (r1)+
              dec r3
              beq toAsciFinish
              br toAsciProcess

toAsciFinish: mov (sp)+, r3
            mov (sp)+, r2
            mov (sp)+, r1
            rts pc

;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

;Output is stored in OrigImg
encode:   ; 2(sp) - key, 4(sp) - hash, 6(sp) - nCols, 10(sp) - nRows, 12(sp) - OrigImg
          ; reveives the stack in the following way:
          ; push OrigImg
          ; push nRows
          ; push nCols
          ; push Hash
          ; push Key
          mov 12(sp), -(sp)         ;store the OrigImg pointer, so we can update it we the work on the current block
          mov r5, -(sp)
          clr r5
          ;Encodes a block, thus encrypting it, mixing and encrypting again.
          ;Makes sure that we stay in the user's dimentions for the image
EncodeBlock:
          mov 2(sp), -(sp)
          mov 10(sp), -(sp)
          mov 16(sp), -(sp)
          jsr pc, EncryptBlock
          tst (sp)+
          tst (sp)+
          tst (sp)+
          mov 2(sp), -(sp)
          mov 12(sp), -(sp)
          mov 16(sp), -(sp)
          jsr pc, MixBlock
          tst (sp)+
          tst (sp)+
          tst (sp)+
          mov 2(sp), -(sp)
          mov 10(sp), -(sp)
          mov 16(sp), -(sp)
          clr r5
          jsr pc, EncryptBlock
          tst (sp)+
          tst (sp)+
          tst (sp)+

          mov r4, -(sp)       ;use r4 as a temp var for mul
          mov r3, -(sp)       ;use r3 as a temp var for mul
          clr r3
          movb @16(sp), r4    ;copy nCols
          mov 16(sp), r3      ;copy nRows
          inc r3
          movb (r3), r3
          mul r4, r3          ;we know the image size is less then 2^16
          mov r3, r4
          add 22(sp), r4      ; 22(sp) is the place where encode got OriImg address
          sub r5, r4          ;if we exceeded the blocks - should be negative
          tst r4
          bmi EMoveBlockRight
          tst r4
          bne EDownMoveBlock
          ;moves to the right block, i.e: moves 4 columns forward
EMoveBlockRight:
          sub r3, r5          ;initialize the OrigImg pointer to the first line in the column.
          mov r5, 6(sp)       ;basically we substract the multiplication of nColsxnRows from the current
                              ;place in the image's pointer (stored in 2(sp))
          add #4, 6(sp)       ;move to next block from right
          mov 6(sp), r4
          clr r3
          movb @16(sp), r3    ;copy nCols value to r3
          sub r3, r4
          mov 22(sp), r3
          sub r4, r3
          beq EEndEncodeR     ;if the result=0, we exceeded nCols

          mov (sp)+, r3
          mov (sp)+, r4
          br EncodeBlock
          ; moves to the next block which is down. i.e: adds 4 rows
EDownMoveBlock:
          mov (sp)+, r3
          mov (sp)+, r4
          mov r5, 2(sp)
          br EncodeBlock
          br DendEncode
          ; if we finished encoding the image.
EEndEncodeR:
          mov (sp)+, r3
          mov (sp)+, r4
DendEncode:
          mov (sp)+, r5
          tst (sp)+           ;pull the r5 we pushed earlier to return r1's value from the encription
          rts pc

          ;The encryption itself. uses xor for encrypting Key's value and Img's byte value.
EncryptBlock:  ; 14(sp) - nCols address, 16(sp) - Key address, 20(sp) - OImg address
               ; Order of passing parameters:
               ; push Image address
               ; push Key address
               ; push nCols address
          mov r1, -(sp)
          mov r2, -(sp)
          mov r4, -(sp)
          mov r5, -(sp)
          mov r3, -(sp)
          clr r4
          mov 20(sp), r1
          mov 16(sp), r2
          mov @14(sp), r4
          bic #177400, r4                 ;gets lower byte of r4, which is nCols
          mov #4, r5                      ;set counters for sob
          mov #4, r3
          ;encrypts line-line (row) in the block
LineEncrypt:
          mov r2,-(sp)                    ;store current node and put it's value in r2
          mov (r2),r2
          mov r1,-(sp)                    ;because r1 is byte, we store r1's address and move into it the value for xoring
          clr r1
          movb @0(sp), r1
          xor r2,r1
          movb r1, @0(sp)
          mov (sp)+, r1
          inc r1
          mov (sp)+, r2
          add #2, r2                       ;moves to next node in key
          cmp @(r2), #177777
          beq EGetNewKey                    ;cycles again the key if nil
          tst(r2)
          bne EKeyIsOk
          ; if key was null, or -1, we rotate the key the start.
EGetNewKey:
          mov 16(sp), r2
          sob r5, LineEncrypt
          br ENextLine
EKeyIsOk: mov (r2), r2                    ;get address of new key node
          sob r5, LineEncrypt
          ;continue to the next row in the block
ENextLine: sub #4, r1                       ;mov r1 to the beginning of line
          add r4, r1                      ;moves r4 one line forward
          mov #4, r5
          sob r3, LineEncrypt
          mov (sp)+, r3
          mov (sp)+, r5
          mov r1, r5
          mov (sp)+, r4
          mov (sp)+, r2
          mov (sp)+, r1
          rts pc

MixBlock: ; 14(sp) - nCols address, 16(sp) - Hash address, 20(sp) - OImg address
           ; Order of passing parameters:
           ; push Image address
           ; push Hash address
           ; push nCols address
          mov r1, -(sp)
          mov r2, -(sp)
          mov r4, -(sp)
          mov r5, -(sp)
          mov r3, -(sp)
          clr r4
          mov 20(sp), r1
          mov 16(sp), r2
          mov @14(sp), r4
          bic #177400, r4
          mov #4, r5
          mov #4, r3
          mov #4, -(sp)       ; counter for cyclic move
          ;mixes the block. first uses the Hash function, then moves the rows in a cyclic procedure.
MixLine:
          mov r2, -(sp)
          mov r1, -(sp)       ; stores r1-index to img, r2-index to hash

          movb (r1), r1       ;get the value in image to use as index in Hash
          add r1, r2          ;advance r2 to desired index
          mov (sp)+, r1
          movb (r2), r2
          movb r2, (r1)+
          mov (sp)+, r2
          sob r3, MixLine
          sub #4, r1          ; initialize r1 to points to the first element in line

          mov r5,(sp)
          sub #4, (sp)        ;checks if cyclic move needs to be taken and how many moves should be done
          neg (sp)
          tst (sp)
          beq MNextLine
          mov r5, -(sp)       ;use r5 as counter for cyclic moves
          mov r3, -(sp)       ;use r3 as a temp register
          ; Cyclic operation
ERepCyclicOp:
          clr r3
          mov #3, r5
          add #3, r1          ;r1 should point to the last element in line
          movb (r1), r3

ECyclicOpLine:   dec r1              ;move the value of (r1) to the next byte
          movb (r1), 1(r1)
          dec r5
          bne ECyclicOpLine          ;if finished the cyclic move, continue
          movb r3, (r1)
          dec 4(sp)
          bne ERepCyclicOp        ;if finished cyclic operation on the line, continue
          mov (sp)+, r3
          mov (sp)+, r5
MNextLine:
          add r4, r1
          mov #4, r3
          sob r5, MixLine
          tst (sp)+
          mov (sp)+, r3
          mov (sp)+, r5
          mov (sp)+, r4
          mov (sp)+, r2
          mov (sp)+, r1
          rts pc

;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

; recevies num of args to print, then the string addresses
; Stack:
; - return address
; - num of args
; - addresses
; this subrutine prints all given strings in stack

printText:  mov r0, -(sp)
            tst -(sp)      ; index for current string to print in the stack
            mov r1,-(sp)      ; string iterator
            mov #12, 2(sp)   ; advance the index to the first string
            mov 10(sp), r0  ; r0 = num of args
PTprintString:
            clr r1
            add 2(sp), r1
            add #2, 2(sp)     ; point to next string
            add sp, r1        ; r1 will point to the current string to print in the stack

PTprintLoop:  tstb @#tps
            bpl PTprintLoop
            cmpb @(r1), #'&
            beq PTstringEnd
            movb @(r1), @#tpb
            inc (r1)
            br PTprintLoop

PTstringEnd:  sob r0, PTprintString

            mov (sp)+, r1
            tst (sp)+
            mov (sp)+, r0
            rts pc

;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

; receives the following stack:
; return address
; string to compare
; output: 0\1
; 1 - if the given string is not equal
; 0 - if the given string is equal
; the second string is transfered INLINE
cmpStr:   mov r1, -(sp)
          mov r2, r1
CSequal:  cmpb (r1)+, @4(sp)
          bne CSnequal
          inc 4(sp)               ;advances string to compare to
          cmpb (r1), #'&
          beq CSexit
          br CSequal

CSnequal:    mov #1, 4(sp)
          br CSend
CSexit:
          mov #0, 4(sp)
          br CSend

CSend:    mov r2, -(sp)
          clr -(sp)
          jsr pc, strlen
          add (sp), r2
          bit #1, r2
          beq CSfin
          inc r2
CSfin:    cmp (sp)+, (sp)+
          mov (sp)+, r1
          rts r2


; recevies the following stack (HOW THE STACK LOOKS WHEN ENTERS THE PROC):
; return address
; len of string after calculation (enters empty)
; string itself (addr)

strlen: mov r1, -(sp)
        mov 6(sp), r1       ;4(sp) = string
        clr 4(sp)
strloop:  cmpb (r1), #'&
          beq strFin
          inc 4(sp)         ;6(sp) = strlen counter
          inc r1
          br strloop
strFin:   inc 4(sp)         ;counts the '&'
          mov (sp)+, r1
          rts pc

;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

; Recevies the following stack:
; return address
; recevied string
; empty space for new string output

nextArgCmd: mov r1, -(sp)
            mov 4(sp), r1

NAloop:     cmpb (r1), #'&
            beq NAamper
            cmpb (r1), #'@
            beq NAsht
            inc r1
            br NAloop
NAamper:    mov r1, 6(sp)
            inc 6(sp)
            br NAend

NAsht:      mov r1, 6(sp)
NAend:      mov (sp)+, r1
            rts pc

;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

parseCmd:
; this subrutine doesnt get any input values
; it removes all unnessery spaces in TEMPCMD and formatted the command to be like "encode&4&4&@"
; & represents an end of a single word in the command
; @ represents an end of a command line
; all data is stored in CMDLINE label

      mov r0, -(sp)
      mov r1, -(sp)
      mov r2, -(sp)
      mov #TEMPCMD, r0
      mov #CMDLINE, r1
      clr r2

                cmpb (r0), #40
                beq prsCmdClr

prsCmdPrcs:     cmp r2, #50
                bhis prsCmdFinish
                cmpb (r0), #'&
                beq prsCmdFinish
                cmpb (r0), #40         ;40=" "
                beq prsCmdSpace
                inc r2
                movb (r0)+, (r1)+
                br prsCmdPrcs

prsCmdSpace:    inc r0
                movb #'&, (r1)+
prsCmdClr:      cmp r2, #50
                bhis prsCmdFinish
                cmpb (r0), #'&
                beq prsCmdFinish
                cmpb (r0), #40         ;40=" "
                bne prsCmdPrcs
                inc r2
                inc r0
                br prsCmdClr

prsCmdFinish:   movb #'&, (r1)+
                movb #'@, (r1)
                mov (sp)+, r2
                mov (sp)+, r1
                mov (sp)+, r0
                rts pc

;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

finish: halt
mainPrmt: .ascii<Welcome!\n\r&>
cmdPrmt: .ascii<$ &>
quitPrmt: .ascii<Goodbye!\n\r&>
unknownPrmt: .ascii<Unknown command &>
dotPrmt: .ascii<.\n\r&>
encPrmt1: .ascii<Please enter image to encode\n\r&>
encPrmt2: .ascii<\n\rThe encoded image is:\n\r&>
decPrmt1: .ascii<Please enter image to decode\n\r&>
decPrmt2: .ascii<\n\rThe decoded image is:\n\r&>
setKeyPrmp: .ascii<Encryption key set to &>
crkPrmt1: .ascii<Please enter image\n\r&>
crkPrmt2: .ascii<\n\rPlease enter encoded image\n\r&>
crkPrmt3: .ascii<\n\rThe key is: &>
newLinePrmt: .ascii<\n\r&>
Hash:  .byte  0,1,2,3,4,5,6,7,10,11,12,13,14,15,16,17
IMG1Cols: .byte 0
IMG1Rows: .byte 0
IMG3Cols: .byte 0
IMG3Rows: .byte 0
KeyMaxSize: .byte 0
Ctrl: .byte 0
.even
IMGIT: .word 0
CMDIT: .word 0
ROWSADR: .word 0
COLSADR: .word 0
TEMPCMD: .blkw 50
CMDLINE: .blkw 50
KeyUse: .word 0, 0
        .blkw 100
Key: .blkw 100
KeyStr: .blkw 100
TEMPIMG: .blkw 1000

;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

rate: .word 1000.
IMG1: .blkw 1000
IMG2: .blkw 1000
IMG3: .blkw 1000
